一、数组中重复的数字：   
（1）每个数字放到其下标对应的位置上  时间O(n),空间O(1)
（2）如果不能修改原始数组，则用范围二分，对范围内数组中的元素个数计数

二、二维数组中的查找： 
    从最右上角元素开始比对，如果大于目标元素则忽略这一列，如果小于目标元素则忽略这一行
，如果等于则找到


三、字符串替换空格 
    首先遍历一次字符串，找出空格数目，即可计算出替换后字符串的长度，两个指针分别p1指向原字符串末尾和p2指向替换后字符串的末尾，分别向前遍历，如果p1指针遇到空格则，p2加上替换的字符串

四、从尾到头打印单链表
    先想到用栈的思想，但是空间就花费较多，因此可以用递归法模拟栈的思路，每次遍历到一个节点，先递归输出其后面的节点，再输出节点本身的值

五、重建二叉树
    根据前序遍历和中序遍历，构建二叉树

六、二叉树的下一节点，给定一个二叉树和其中一个节点，找到中序遍历的下一个节点
    如果该节点有右子树，则下一个节点为右子树中最左子节点，
    如果该节点没有右子树，且其为父节点的左孩子，那么下一个节点就是父节点
    如果该节点没有右子树，且其是父节点的右孩子，则沿着父节点指针一直向上遍历，直到找到一个节点是其父结点的左子节点，返回这个节点的父节点

七、用两个栈实现队列
    如果stack2不为空，将stack2中栈顶元素弹出，当stack2为空，将stack1中的元素逐个弹出并压入stack2
    两个队列实现一个栈，进栈就是进入不为空的队列，出栈把不为空的队列留下最后一个元素，其他都入另一个队列

八、斐波那契数列（青蛙跳台阶）
    记得不要用递归，用dp

九、插入排序、冒泡排序、归并排序、快排，要会写且比较时间复杂度和空间复杂度

十、旋转数组中的最小数字，把一个递增数组旋转（最开始的几个元素搬到数组末尾），输出旋转数组的最小值
    O(logn)二分法

十一、矩阵中的路径，判断矩阵中是否存在一个包含某个字符串所有字符的路径，不能重复走
    回溯法，还需要定义一个与字符矩阵相同大小的布尔值矩阵，用来标记是否已经进入这个格子

十二、机器人的运动范围，在m行n列的方格，从（0,0）开始上下左右移动，不能进入行坐标与纵坐标数位之和大于k的格子，问能到达多少个格子。
    回溯，也需要一个布尔值矩阵判断是否进来过，注意边界值判断

十三、剪绳子，给一个长度为n的绳子剪成m段，m段最大乘积是多少
    dp，f(n)= max(f(i)*f(n-i)) 0<i<n

十四、二进制中1的个数
    把一个整数减去1，再和原整数做与运算，这样会把整数最右边的1变成0，循环往复并计数即可
