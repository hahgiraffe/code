<!--
 * @Description: 
 * @Author: haha_giraffe
 * @Date: 2019-07-26 12:11:38
 -->
1. 数组中重复的数字<br/> 
（1）每个数字放到其下标对应的位置上  时间O(n),空间O(1)<br/>
（2）如果不能修改原始数组，则用范围二分，对范围内数组中的元素个数计数

2. 二维数组中的查找<br/>
    从最右上角元素开始比对，如果大于目标元素则忽略这一列，如果小于目标元素则忽略这一行，如果等于则找到

3. 字符串替换空格<br/>
    首先遍历一次字符串，找出空格数目，即可计算出替换后字符串的长度，两个指针分别p1指向原字符串末尾和p2指向替换后字符串的末尾，分别向前遍历，如果p1指针遇到空格则，p2加上替换的字符串

4. 从尾到头打印单链表<br/>
    先想到用栈的思想，但是空间就花费较多，因此可以用递归法模拟栈的思路，每次遍历到一个节点，先递归输出其后面的节点，再输出节点本身的值

5. 重建二叉树<br/>
    根据前序遍历和中序遍历，构建二叉树

6. 二叉树的下一节点，给定一个二叉树和其中一个节点，找到中序遍历的下一个节点<br/>
    如果该节点有右子树，则下一个节点为右子树中最左子节点，
    如果该节点没有右子树，且其为父节点的左孩子，那么下一个节点就是父节点
    如果该节点没有右子树，且其是父节点的右孩子，则沿着父节点指针一直向上遍历，直到找到一个节点是其父结点的左子节点，返回这个节点的父节点

7. 用两个栈实现队列<br/>
    如果stack2不为空，将stack2中栈顶元素弹出，当stack2为空，将stack1中的元素逐个弹出并压入stack2
    两个队列实现一个栈，进栈就是进入不为空的队列，出栈把不为空的队列留下最后一个元素，其他都入另一个队列

8. 斐波那契数列（青蛙跳台阶）<br/>
    记得不要用递归，用dp

9. 插入排序、冒泡排序、归并排序、快排，要会写且比较时间复杂度和空间复杂度<br/>

10. 旋转数组中的最小数字,输入一个递增数组的旋转，即把一个递增数组旋转（最开始的几个元素搬到数组末尾），输出旋转数组的最小值<br/>
    O(logn)二分法

11. 矩阵中的路径，判断矩阵中是否存在一个包含某个字符串所有字符的路径，不能重复走<br/>
    回溯法，还需要定义一个与字符矩阵相同大小的布尔值矩阵，用来标记是否已经进入这个格子

12. 机器人的运动范围，在m行n列的方格，从（0,0）开始上下左右移动，不能进入行坐标与纵坐标数位之和大于k的格子，问能到达多少个格子<br/>
    回溯，也需要一个布尔值矩阵判断是否进来过，注意边界值判断

13. 剪绳子，给一个长度为n的绳子剪成m段，m段最大乘积是多少<br/>
    dp，f(n)= max(f(i)*f(n-i)) 0<i<n

14. 二进制中1的个数<br/>
    把一个整数减去1，再和原整数做与运算，这样会把整数最右边的1变成0，循环往复并计数即可

15. 数值的整数次方pow(double m,int n);<br/>
    这个问题主要考虑输入输出错误，n为负数，m为0等情况

16. 打印从1到最大的n位数<br/>
    字符串操作，把起放到vector中，全排列递归得解

17. 删除链表节点，在O(1)时间内删除节点<br/>
    将指向删除节点的指针的下一个节点的值赋值给想要删除的节点，然后删除下一个节点

18. 删除链表中重复节点<br/>
    重点是保证三个指针

19. 正则表达式匹配<br/>
    输入两个字符串，一个是被匹配的字符串，另一个是包含正则表达式的模式串。这道题要用递归来比较模式串与字符串的每一位,同时要注意模式串下一位为'*'的情况

20. 表示数值的字符串<br/>
    输入一个表示数值的字符串，判断其是否符合要求，首先要知道规则，一直遍历即可

21. 调整数组顺序使奇数位于偶数前<br/>
    如果不用考虑奇数与奇数之间的相对位置（或偶数与偶数之间的相对位置）直接双指针即可
    如果要考虑相对位置，则先从头找到第一个偶数a，然后从这个偶数开始继续找到第一个奇数b，为了保证相对顺序，把b提出来为tmp，且a-b之间整体后移一位数,再把tmp赋值给a位置

22. 链表中倒数第k个节点<br/>
    这个双指针就行，注意输入条件的几点（输入链表为空，k>链表长度，k=0等情况）

23. 链表中环的入口节点<br/>
    首先判断链表中是否有环，快慢指针（如果相遇则说明有环）,接着找环中节点的数目（从快慢指针相遇的位置，再往后遍历，直到找到原指针），然后从头，快指针先走环中节点的数量，然后快慢指针一起走，相遇的地方即为环入口节点

24. 反转链表<br/>
    较为简单，测试输入在空或输入为一个节点的即可。注意中间三指针的逻辑。

25. 合并两个排序的链表<br/>
    比较合并即可

26. 树的子结构<br/>
    判断一个树是否是另一个树的子树，首先根据根节点对比，如果不同则跳过，相同则递归遍历两棵树即可

27. 二叉树的镜像<br/>
    这个就是递归交换左右子节点即可

28. 对称的二叉树<br/>
    这个就是传入两个指针指向根，一个往左走，一个往右走即可

29. 顺时针打印矩阵<br/>
    输入一个矩阵，顺时针打印每个数字。这道题思路不难，就是按照圈打印，以左上节点为核心进行判断，每次加1，主要是边缘条件的判断

30. 包含min函数的栈<br/>
    思路就是要一个数据栈，辅助栈，辅助栈顶永远保持数据栈中最小的元素，当push的时候，若辅助栈为空或辅助栈顶元素小于插入的元素，则辅助栈push插入元素，其他时间辅助栈再一次push辅助栈顶元素

31. 栈的压入、弹出序列<br/>
    两个整数序列，一个表示压栈的顺序，判断第二个序列是否可能为弹出的序列。用一个栈作为存储，两个index分别为输入序列和输出序列，主要判断栈顶元素是否为输出序列中下一个元素，若是则弹出，若不是则输入序列向栈中输入元素。

32. 从上到下打印二叉树<br/>
    层次遍历二叉树（广度优先用队列）<br/>
    如果是要分层打印节点的值，也可以用dfs，level值递归求解过程，这样可以得到每一层的节点数并放到一个二维数组中<br/>
    之字形打印二叉树,如果用bfs比较复杂，最好的方法就是先分层打印，然后单数层数的层reverse就行

33. 二叉搜索树后序遍历序列<br/>
    注意！二叉树的前序中序后序的非递归都要会写！
