1. 数组中重复的数字<br/> 
（1）每个数字放到其下标对应的位置上  时间O(n),空间O(1)<br/>
（2）如果不能修改原始数组，则用范围二分，对范围内数组中的元素个数计数

2. 二维数组中的查找<br/>
    从最右上角元素开始比对，如果大于目标元素则忽略这一列，如果小于目标元素则忽略这一行，如果等于则找到

3. 字符串替换空格<br/>
    首先遍历一次字符串，找出空格数目，即可计算出替换后字符串的长度，两个指针分别p1指向原字符串末尾和p2指向替换后字符串的末尾，分别向前遍历，如果p1指针遇到空格则，p2加上替换的字符串

4. 从尾到头打印单链表<br/>
    先想到用栈的思想，但是空间就花费较多，因此可以用递归法模拟栈的思路，每次遍历到一个节点，先递归输出其后面的节点，再输出节点本身的值

5. 重建二叉树<br/>
    根据前序遍历和中序遍历，构建二叉树

6. 二叉树的下一节点，给定一个二叉树和其中一个节点，找到中序遍历的下一个节点<br/>
    如果该节点有右子树，则下一个节点为右子树中最左子节点，
    如果该节点没有右子树，且其为父节点的左孩子，那么下一个节点就是父节点
    如果该节点没有右子树，且其是父节点的右孩子，则沿着父节点指针一直向上遍历，直到找到一个节点是其父结点的左子节点，返回这个节点的父节点

7. 用两个栈实现队列<br/>
    如果stack2不为空，将stack2中栈顶元素弹出，当stack2为空，将stack1中的元素逐个弹出并压入stack2
    两个队列实现一个栈，进栈就是进入不为空的队列，出栈把不为空的队列留下最后一个元素，其他都入另一个队列

8. 斐波那契数列（青蛙跳台阶）<br/>
    记得不要用递归，用dp

9. 插入排序、冒泡排序、归并排序、快排，要会写且比较时间复杂度和空间复杂度<br/>

10. 旋转数组中的最小数字,输入一个递增数组的旋转，即把一个递增数组旋转（最开始的几个元素搬到数组末尾），输出旋转数组的最小值<br/>
    O(logn)二分法

11. 矩阵中的路径，判断矩阵中是否存在一个包含某个字符串所有字符的路径，不能重复走<br/>
    回溯法，还需要定义一个与字符矩阵相同大小的布尔值矩阵，用来标记是否已经进入这个格子

12. 机器人的运动范围，在m行n列的方格，从（0,0）开始上下左右移动，不能进入行坐标与纵坐标数位之和大于k的格子，问能到达多少个格子<br/>
    回溯，也需要一个布尔值矩阵判断是否进来过，注意边界值判断

13. 剪绳子，给一个长度为n的绳子剪成m段，m段最大乘积是多少<br/>
    dp，f(n)= max(f(i)*f(n-i)) 0<i<n

14. 二进制中1的个数<br/>
    把一个整数减去1，再和原整数做与运算，这样会把整数最右边的1变成0，循环往复并计数即可

15. 数值的整数次方pow(double m,int n);<br/>
    这个问题主要考虑输入输出错误，n为负数，m为0等情况

16. 打印从1到最大的n位数<br/>
    字符串操作，把起放到vector中，全排列递归得解

17. 删除链表节点，在O(1)时间内删除节点<br/>
    将指向删除节点的指针的下一个节点的值赋值给想要删除的节点，然后删除下一个节点

18. 删除链表中重复节点<br/>