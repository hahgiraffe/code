<!--
 * @Description: 
 * @Author: haha_giraffe
 * @Date: 2019-07-26 12:11:38
 -->
1. 数组中重复的数字<br/> 
（1）每个数字放到其下标对应的位置上  时间O(n),空间O(1)<br/>
（2）如果不能修改原始数组，则用范围二分，对范围内数组中的元素个数计数

2. 二维数组中的查找<br/>
    从最右上角元素开始比对，如果大于目标元素则忽略这一列，如果小于目标元素则忽略这一行，如果等于则找到

3. 字符串替换空格<br/>
    首先遍历一次字符串，找出空格数目，即可计算出替换后字符串的长度，两个指针分别p1指向原字符串末尾和p2指向替换后字符串的末尾，分别向前遍历，如果p1指针遇到空格则，p2加上替换的字符串

4. 从尾到头打印单链表<br/>
    先想到用栈的思想，但是空间就花费较多，因此可以用递归法模拟栈的思路，每次遍历到一个节点，先递归输出其后面的节点，再输出节点本身的值

5. 重建二叉树<br/>
    根据前序遍历和中序遍历，构建二叉树

6. 二叉树的下一节点，给定一个二叉树和其中一个节点，找到中序遍历的下一个节点<br/>
    如果该节点有右子树，则下一个节点为右子树中最左子节点，
    如果该节点没有右子树，且其为父节点的左孩子，那么下一个节点就是父节点
    如果该节点没有右子树，且其是父节点的右孩子，则沿着父节点指针一直向上遍历，直到找到一个节点是其父结点的左子节点，返回这个节点的父节点

7. 用两个栈实现队列<br/>
    如果stack2不为空，将stack2中栈顶元素弹出，当stack2为空，将stack1中的元素逐个弹出并压入stack2
    两个队列实现一个栈，进栈就是进入不为空的队列，出栈把不为空的队列留下最后一个元素，其他都入另一个队列

8. 斐波那契数列（青蛙跳台阶）<br/>
    记得不要用递归，用dp

9. 插入排序、冒泡排序、归并排序、快排，要会写且比较时间复杂度和空间复杂度<br/>

10. 旋转数组中的最小数字,输入一个递增数组的旋转，即把一个递增数组旋转（最开始的几个元素搬到数组末尾），输出旋转数组的最小值<br/>
    O(logn)二分法

11. 矩阵中的路径，判断矩阵中是否存在一个包含某个字符串所有字符的路径，不能重复走<br/>
    回溯法，还需要定义一个与字符矩阵相同大小的布尔值矩阵，用来标记是否已经进入这个格子

12. 机器人的运动范围，在m行n列的方格，从（0,0）开始上下左右移动，不能进入行坐标与纵坐标数位之和大于k的格子，问能到达多少个格子<br/>
    回溯，也需要一个布尔值矩阵判断是否进来过，注意边界值判断

13. 剪绳子，给一个长度为n的绳子剪成m段，m段最大乘积是多少<br/>
    dp，f(n)= max(f(i)*f(n-i)) 0 < i < n

14. 二进制中1的个数<br/>
    把一个整数减去1，再和原整数做与运算，这样会把整数最右边的1变成0，循环往复并计数即可

15. 数值的整数次方pow(double m,int n);<br/>
    这个问题主要考虑输入输出错误，n为负数，m为0等情况

16. 打印从1到最大的n位数<br/>
    字符串操作，把起放到vector中，全排列递归得解

17. 删除链表节点，在O(1)时间内删除节点<br/>
    将指向删除节点的指针的下一个节点的值赋值给想要删除的节点，然后删除下一个节点

18. 删除链表中重复节点<br/>
    重点是保证三个指针

19. 正则表达式匹配<br/>
    输入两个字符串，一个是被匹配的字符串，另一个是包含正则表达式的模式串。这道题要用递归来比较模式串与字符串的每一位,同时要注意模式串下一位为'*'的情况

20. 表示数值的字符串<br/>
    输入一个表示数值的字符串，判断其是否符合要求，首先要知道规则，一直遍历即可

21. 调整数组顺序使奇数位于偶数前<br/>
    如果不用考虑奇数与奇数之间的相对位置（或偶数与偶数之间的相对位置）直接双指针即可
    如果要考虑相对位置，则先从头找到第一个偶数a，然后从这个偶数开始继续找到第一个奇数b，为了保证相对顺序，把b提出来为tmp，且a-b之间整体后移一位数,再把tmp赋值给a位置

22. 链表中倒数第k个节点<br/>
    这个双指针就行，注意输入条件的几点（输入链表为空，k>链表长度，k=0等情况）

23. 链表中环的入口节点<br/>
    首先判断链表中是否有环，快慢指针（如果相遇则说明有环）,接着找环中节点的数目（从快慢指针相遇的位置，再往后遍历，直到找到原指针），然后从头，快指针先走环中节点的数量，然后快慢指针一起走，相遇的地方即为环入口节点

24. 反转链表（常考）<br/>
    较为简单，测试输入在空或输入为一个节点的即可。注意中间三指针的逻辑。

25. 合并两个排序的链表<br/>
    比较合并即可

26. 树的子结构<br/>
    判断一个树是否是另一个树的子树，首先根据根节点对比，如果不同则跳过，相同则递归遍历两棵树即可

27. 二叉树的镜像<br/>
    这个就是递归交换左右子节点即可

28. 对称的二叉树<br/>
    这个就是传入两个指针指向根，一个往左走，一个往右走即可

29. 顺时针打印矩阵<br/>
    输入一个矩阵，顺时针打印每个数字。这道题思路不难，就是按照圈打印，以左上节点为核心进行判断，每次加1，主要是边缘条件的判断

30. 包含min函数的栈<br/>
    思路就是要一个数据栈，辅助栈，辅助栈顶永远保持数据栈中最小的元素，当push的时候，若辅助栈为空或辅助栈顶元素小于插入的元素，则辅助栈push插入元素，其他时间辅助栈再一次push辅助栈顶元素

31. 栈的压入、弹出序列<br/>
    两个整数序列，一个表示压栈的顺序，判断第二个序列是否可能为弹出的序列。用一个栈作为存储，两个index分别为输入序列和输出序列，主要判断栈顶元素是否为输出序列中下一个元素，若是则弹出，若不是则输入序列向栈中输入元素。

32. 从上到下打印二叉树<br/>
    层次遍历二叉树（广度优先用队列）<br/>
    如果是要分层打印节点的值，也可以用dfs，level值递归求解过程，这样可以得到每一层的节点数并放到一个二维数组中<br/>
    之字形打印二叉树,如果用bfs比较复杂，最好的方法就是先分层打印，然后单数层数的层reverse就行

33. 二叉搜索树后序遍历序列<br/>
    注意！二叉树的前序中序后序的非递归都要会写！这道题目是判断一个数组是否为二叉搜索树的后序遍历结果，递归遍历即可，拿出最后一个数与前面比较，找到第一个比其大的数，若满足之前都比其小，之后都比其大则满足条件，注意边界条件<br/>
    （1）二叉树的前序非递归遍历，很简单，用栈，先放右子节点，再放左子节点
    （2）二叉树的后序非递归遍历，要保证左子树和右子树访问完成，再访问根节点，也是用一个栈还需要一个指针表示上一个访问的节点，当前节点为栈顶元素如果当前节点的左右子树为空，或者上个访问节点为左右子树中的一个，则弹出栈顶，否则将左右子树压入栈

34. 二叉树中和为某一值的路径<br/>
    遍历存储打印即可

35. 复杂链表的复制<br/>
    第一步，遍历链表将每个原节点在其后复制一个节点（只写next指针），第二步，根据原节点再次遍历，在复制的节点上加上random指针，第三步，将复制的节点提取出来即可，写的时候小心指针操作

36. 二叉搜索树与双向链表<br/>
    重点在于，对于每个节点及其左右子树，首先中序遍历，先遍历左子树，多加上一个指针指向最后一个节点（值最大的节点），因为当前节点要和左子树中最后一个节点相连，接着遍历右子树
    
37. 序列化二叉树<br/>
    利用前序遍历，思想比较简单

38. 字符串的排列<br/>
    打印字符串的全排列，对于每位字符，交换其与后面的字符，然后继续递归
    相似题目：八皇后、八个数放正方形问题

39. 数组中出现次数超过一半的数字<br/>
    方法一：快排的partition，相当于把问题变成找中位数(第n/2个数)
    方法二：遍历数组，保存两个变量res和num.如果遍历的数＝＝res，则num++，如果不同则num--，若为０则res=这个数且num=1

40. 最小的k个数<br/>
    方法一：快排partition,找到第k个数，并且左边都是比其小的数字，但是要改变数组中元素的位置
    方法二：用红黑树或者最大堆存储k个值，每次来值进行比较，一直保留最小的k个数

41. 数据流中的中位数<br/>
    用STL中的堆实现，make_heap,push_heap,pop_heap,sort_heap

42. 连续子数组最大和<br/>
    典型dp，状态转移方程 dp[i]表示以i结尾的子数组最大和，dp[i]=max(num[i],num[i]+dp[i-1]);然后遍历整个dp数组取最大值即可

43. 1～n整数中1出现次数<br/>
    这道题目常规方法很简单，但是需要遍历到每个数字中的每一位，复杂度较高，高级方法感觉就是找规律递归，没啥意思

44. 数字序列中某一位的数字<br/>
    这题基本上也是在找规律

45. 把数组排列成最小的数<br/>
    首先要想到如果整型直接拼接可能会产生越界，所以要先把整型转换成字符串，然后直接sort比较，把两个字符串拼接成较小的放前面

46. 把数字翻译成字符串<br/>
    按照一定规则，输出有多少种翻译的方法，其实直接递归就行

47. 礼物的最大价值<br/>
    就是一个二维数组，从坐上出发，只能往下或者右走，求到达右下角时候的最大值，简单的二维dp即可，dp[i][j]=max(dp[i-1][j],dp[i][j-1])+num[i][j]
    优化方法可以将二维dp变成一维的dp[i]表示纵坐标为i的列中最大值（这种方法没有实现过，有待尝试）

48. 最长不重复字符的子字符串<br/>
    dp，我想的是dp[i]表示以i结尾的不重复字符串最大长度，同时要保持一个set存储dp[i-1]时候的集合，如果num[i]不在集合中dp[i]=dp[i-1]+1，如果在集合中，则需要从当前节点往前遍历set和dp[i]

49. 丑数<br/>
    查找第n个丑数（因子只包含2,3,5的数），最简单的方法就是每个数遍历查看是否是丑数
    稍微好一点的方法，用一个数组按序存储丑数，空间换时间的想法，2,3,5每个一个index存储自己的位置，比较生成最小的丑数放入排序数组

50. 第一个只出现一次的字符<br/>
    思路就是用map存储，然后好一点的方法就是用vector替代map

51. 数组中的逆序对<br/>
    这题有点难度，就是用归并排序的思想，但是在归并的时候判断有多少个逆序对，还需要多加练习

52. 两个链表的第一个公共节点<br/>
    先遍历两个链表，分别找到长度，然后长的先走两个链表的长度差，然后再一起走，双指针的思想

53. 在排序数组中查找数字<br/>
    题目一：在一个排序数组中查找某个数字出现的次数，二分查找的变形，首先递归查找出现的第一个位置，然后递归查找最后一个位置，再相减即可。
    题目二：0~n-1中缺失的数字，发现缺失的数字m就是第一个数值与下标不相等的元素，也是二分的变形
    题目三：在一个单调递增的数组中每个元素都是唯一，找到数组中任意一个数值等于其下标的元素，典型的二分

54. 二叉搜索树的第k大个节点<br/>
    二叉搜索树中序遍历得到的序列就是从小到大，参数多一个数组即可，返回vec[k-1]，同时判断一下k与vec.size()

55. 二叉树深度<br/>
    题目一：求二叉树的深度，直接dfs即可
    题目二：判断一个树是否是平衡树（任意节点左右子树深度相差不超过1），沿用上题思想，先求任意节点左右子树深度，再比较

56. 数组中数字出现的次数<br/>
    题目一：数组中只出现一次的两个数字，首先遍历异或，在结果中找从右往左数第num位为1，根据num位是否为1把原数组分成两个数组，两个数组中各包含一个只出现一次的数字，再次异或即可
    题目二：数组中只有一个数字出现一次，其余数字出现三次，找到出现一次数字，把所有数字的二进制位每一位加起来，如果某一位的和能被3整除，说明只出现一次的那个数字该位为0，否则为1

57. 和为s的数字<br/>
    题目一：在一个递增排序的数组，找两个数字使其和等于s，输出任意一对，双指针，index1=0,index2=arr.size()-1,如果和小于s则index1++,否则index2--
    题目二：和为s的所有连续正数序列，双指针(滑动窗口)，两个指针分别指向序列的最大和最小值，如果序列和小于s，则右指针++，否则左指针++

58. 翻转字符串<br/>
    题目一：翻转单词顺序，先整个翻转，然后找到一个空格，空格之前的单词翻转
    题目二：左旋转字符串，先翻转两个子串，再翻转整个字符串

59. 队列的最大值<br/>
    题目一：滑动窗口最大值，这道题目有点复杂，用到了双端队列deque，两端都要pop
    题目二：队列的最大值

60. n个骰子的点数<br/>
    n个骰子的点数之和为s，输出所有s可能值的概率。每轮多考虑一个骰子，分别用两个数组存储每轮骰子和的个数

61. 扑克牌中的顺子<br/>
    判断一个扑克牌序列是否为连续的，首先排序，然后找出0的个数，然后比较每两个数间隙的个数与0的个数，若小于则是顺子，否则不是顺子

62. 圆圈中最后剩下的数字<br/>
    约瑟夫环问题，找规律后，循环或递归

63. 股票的最大利润<br/>
    遍历一次保留最小值，然后每个比较

64. 求1+2+3...+n <br/>
    用构造函数和static求解

65. 字符串转换成整数atoi<br/>
    这个题目很重要，逻辑不复杂，但是要考虑很多额外因素，包括①正负号，是否只有正负号 ②int溢出 ③输入空字符串 ④ 合格的字符

66. 树中两个节点的最低公共祖先节点<br/> 
    题目可变性多次，多种方法